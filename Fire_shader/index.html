<html>

<head>
  <title>Simple Geometry Test</title>
</head>

<style>
  body {
    margin: 0;
  }

  canvas {
    width: 100%;
    height: 100%;
  }
</style>

<body>
  <link rel="shortcut icon" href="#">


  <style>
    body {
      font-family: Monospace;
      background-color: #000;
      color: #fff;
      margin: 0px;
      overflow: hidden;
    }

    #info {
      position: absolute;
      top: 10px;
      width: 100%;
      text-align: center;
    }
  </style>

  <div id="info">
    <p>GLSL fire shader!</p>
  </div>

  <script type="importmap">
			{
				"imports": {
					"three": "./build/three.module.js",
					"dat.gui": "../node_modules/dat.gui/build/dat.gui.module.js"
				}
			}
		</script>

  <script type="x-shader/x-vertex" id="vertexShaderNormal">
    varying vec3 vNormal;
    varying vec3 vPosition;
    varying vec2 vTextureCoord;
    
    void main()
    {
      vNormal = (normalMatrix * normal);
      vec4 ViewPosition= modelViewMatrix * vec4(position,1.0);
      vPosition = ViewPosition.xyz;
      gl_Position=projectionMatrix * ViewPosition;
    }
  </script>

  <script type="x-shader/x-fragment" id="fragmentShaderNormal">
    uniform float u_time;
    uniform float u_speed;

    varying vec3 vNormal;
    varying vec3 vPosition;
    varying vec2 vTextureCoord;

    void main()
    {
      vec2 st = vPosition.xy;
  
      vec3 firePos = vec3(0, 0.2, 0);
      float strength = 10.0;
      float height = -0.1;
      float range = 3.816;
      float curveSteps = 2.0;
      float flameSteps = 15.0;
      float curveAmount = 0.05;
      
      float dist = distance(firePos, 
                            vec3(st.x + (sin(st.y * curveSteps + (u_time * u_speed)) * curveAmount * (st.y + 1.0)),
                                 st.y * height, 
                                 0.0));
      dist = floor((1.0 - clamp(pow(dist * range, strength), 0.0, 1.0)) * flameSteps) / flameSteps;
      vec3 color = vec3(dist, dist * 0.5, dist * 0.2);
  
      gl_FragColor = vec4(color,1.0);
    }
  </script>

  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from './build/controls/OrbitControls.js';
    import * as dat from 'dat.gui';

    var scene = new THREE.Scene();
    var ratio = window.innerWidth / window.innerHeight;
    var camera = new THREE.PerspectiveCamera(45, ratio, 0.1, 1000);

    camera.position.set(0, 0, 15);
    camera.lookAt(0, 0, 1);

    var renderer = new THREE.WebGLRenderer();
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    const uniforms = {
      u_time: { value: 1.0 },
      u_speed: { value: 1.0 },
    }
    var material_sphere = new THREE.ShaderMaterial();
    material_sphere.vertexShader = document.getElementById('vertexShaderNormal').textContent;
    material_sphere.fragmentShader = document.getElementById('fragmentShaderNormal').textContent;
    material_sphere.uniforms = uniforms;

    //#region GUI
    const gui = new dat.GUI();
    const settingsFolder = gui.addFolder('Settings');

    var geometry_sphere = new THREE.SphereGeometry();
    var geometry_mesh = new THREE.Mesh(geometry_sphere, material_sphere);
    scene.add(geometry_mesh);

    var controls = new OrbitControls(camera, renderer.domElement);

    const clock = new THREE.Clock();
    var MyUpdateLoop = function () {
      renderer.render(scene, camera);
      controls.update();
      uniforms.u_time.value = clock.getElapsedTime();
      requestAnimationFrame(MyUpdateLoop);
    };

    requestAnimationFrame(MyUpdateLoop);

    //this fucntion is called when the window is resized
    var MyResize = function () {
      var width = window.innerWidth;
      var height = window.innerHeight;
      renderer.setSize(width, height);
      camera.aspect = width / height;
      camera.updateProjectionMatrix();
      renderer.render(scene, camera);
    };

    //link the resize of the window to the update of the camera
    window.addEventListener('resize', MyResize);

  </script>
</body>

</html>